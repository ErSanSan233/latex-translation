\chapter{必要工具}

\begin{quote}
    我所爱的，你何其美好。何其可悦，使人欢畅喜乐。你的身量好像棕树。你的两乳如同其上的果子，累累下垂。

    \hfill《圣经·雅歌》7:7
\end{quote}

在本章，我们会介绍创造比第4章中介绍的指令和环境更复杂的指令和环境所需准备的工具。此外，借着本章的介绍，我们旨在说明，此处提到的第4章需要正确消化，才能继续这一部分的阅读。本章也会介绍一些关于字体的机制，以及挖掘\LaTeX 资源的方法。

\section{赫尔克里·波洛}

\subsection{在文件中挖掘信息}

首先，为了让使用\LaTeX 写成的文档带有一些个人特色，需要知道组成你使用的\TeX 或\LaTeX 的发行版的文件的组织方法。鄙人使用了UNIX平台的发行版\TeX Live（\wz{http://www.tug.org/texlive}）。在这个发行版中，我们可以在第一时间在以下目录中查阅各种包的文档：

\begin{dmd}
/usr/share/texmf-texlive/doc/latex/
\end{dmd}

这个目录中包含其他子目录，通常每个子目录对应一个包，其中就以DVI或PostScript文件的形式提供了文档。在一些情况下，需要去检查这些包的源代码。在发行版te\TeX 中，这些源代码位于：

\begin{dmd}
/usr/share/texmf-texlive/tex/latex
\end{dmd}

在同样的位置，我们通常可以为每个包找到一个目录，包含文本形式且带有扩展名\dm{sty}的源代码，在必要时也会包含相关文件。最后，为了独立于我们可以包含的包而了解\LaTeX 的默认行为，可以借助以下位置的\LaTeX 源代码：

\begin{dmd}
/usr/share/texmf-texlive/tex/latex/base/latex.ltx
\end{dmd}

对于文档类型\dm{book}，还可以借助以下位置的文档类型源代码：

\begin{dmd}
/usr/share/texmf-texlive/tex/latex/base/book.cls
\end{dmd}

\subsection{检查宏}

查找指令定义的一个非常便捷的方法是在交互式会话中求助于\LaTeX 。可以直接在操作系统的命令行终端中执行以下指令：

\dmh{latex}

我的系统是这样冷冰冰地回答的：

\begin{dmd}
\begin{verbatim}
This is e-TeXk, Version 3.14159-2.1 (Web2C 7.4.5)
%&-line parsing enabled.
**
\end{verbatim}
\end{dmd}

在“赤裸裸的\TeX ”呼喊出这个冷峻的提示（\dm{**}）的邀请下，我勇敢地回复了\verb|&latex|来要求加载\LaTeX 格式。没有丝毫延迟，就得到了答复：

\begin{dmd}
\begin{verbatim}
**&latex
entering extended mode
LaTeX2e <2001/06/01>
Babel <v3.7h> and hyphenation patterns for american,
french loaded.
*
\end{verbatim}
\end{dmd}

注意，提示中少了一个星号。从现在开始，我们就可以交互式地编写\LaTeX 文档了。从绝对意义商来说，这样做的乐趣不大，但从获取指令的定义和语法上来说，却很有帮助。因此，举例来说，我们可以写下这样的指令：

\begin{dmd}
\verb|*\show|\codereplace{指令}
\end{dmd}

这样可以获取\codereplace{指令}的定义。例如：

\begin{dmd}
\begin{verbatim}
*\show\mbox
> \mbox=\long macro:
\end{verbatim}
\verb|#1->\leavevmode \hbox {#1}.| \quad $\leftarrow$\textsf{此处为定义}\\
\verb+<*> \show\mbox+
\end{dmd}

其中向我们提供了指令\verb|\mbox|的定义。可以注意到，该指令被调用时，将这种调用转化为对\verb|\leavevmode|和\verb|\hbox|的调用。在好奇心的驱使下，我们继续查看指令的定义：

\begin{dmd}
\verb|*\show\hbox|\\
\verb|> \hbox=\hbox.| \quad $\leftarrow$\textsf{这是一个原语}\\
\verb|<*> \show\hbox|
\end{dmd}

可以观察到，\verb|\hbox|不是由其他指令定义而成的。在\TeX 中，这种指令称为原语（primitive）。我们的探索可以继续：

\begin{dmd}
\verb|*\show\leavevmode|\\
\verb|> \leavevmode=macro:|\\
\verb|->\unhbox \voidb@x .|\quad $\leftarrow$\backslash leavevmode\textsf{的定义}\\
\verb|<*> \show\leavevmode|
\end{dmd}

以此类推……

\section{底层工具}

\subsection{百分号图个什么？}

你可能已经注意到，有时\LaTeX 源代码中的行末带有百分号\dm{\%}。基于代码换行时文本间会自动添加空格这样的情况，百分号就有理由出现了。请看如下指令：

\begin{dmd}
\verb|\newcommand{\beurk}{bidule}|
\end{dmd}

为了增强可读性，这条指令可以拆分为多行代码：

\begin{codelist}[9.1]{
\newcommand{\beurk}{
    bidule
}
==(\beurk)==
}\begin{verbatim}
\newcommand{\beurk}{
    bidule
}
==(\beurk)==
\end{verbatim}
\end{codelist}

可以观察到，“bidule”一词的两侧出现了我们不想要的空格。为了避免这种现象，可以使用如下方式改写：


\begin{codelist}[9.2]{
\newcommand{\beurk}{%
    bidule%
}
==(\beurk)==
}\begin{verbatim}
\newcommand{\beurk}{%
    bidule%
}
==(\beurk)==
\end{verbatim}
\end{codelist}

在另一些场景下，空格会为行文带来有害的干预。定义以下环境：

\begin{dmd}
\begin{verbatim}
\newenvironment{hyperimportant}{% 
    \bfseries\itshape}{% 
    \upshape\mdseries}
\end{verbatim}
\end{dmd}

\newenvironment{hyperimportant}{% 
    \bfseries\itshape}{% 
    \upshape\mdseries}

\begin{codelist}[9.3]{
    Il est impératif
\begin{hyperimportant}
  de multiplier les sauvegardes
\end{hyperimportant}
de vos documents personnels
}\begin{verbatim}
Il est impératif
\begin{hyperimportant}
    de multiplier les sauvegardes
\end{hyperimportant}
de vos documents personnels
\end{verbatim}
\end{codelist}

如果仔细观察生成的文本，可以注意到，在粗斜体部分文本“{\bfseries\itshape de ... sauvegardes}”的两侧各有两个空格：

\begin{itemize}
    \item “{\bfseries\itshape de}”前面的两个空格分别由“\dm{impératif}”和begin条目“\verb|\begin{hyperimportant}|”后的换行引入；
    \item “{\bfseries\itshape sauvegardes}”后面的两个空格分别由“\dm{sauvegardes}”和end条目“\verb|\end{hyperimportant}|”后的换行引入。
\end{itemize}

我们可以删除换行，来证明这种观点：

\begin{codelist}[9.4]{
Il est impératif\begin{hyperimportant} de
multiplier  les
sauvegardes\end{hyperimportant} de vos
documents personnels
}\begin{verbatim}
Il est impératif\begin{hyperimportant} de
multiplier  les
sauvegardes\end{hyperimportant} de vos
documents personnels
\end{verbatim}
\end{codelist}

为了防止被这种问题牵扯精力，一般可以求助于两条用于删除双重空格的指令。对于序列之前的双重空格，可以调用指令\verb+\ignorespaces+来消除它；对于序列之后的，可以调用\verb|\unskip|。

\subsubsection{指令\dm{\backslash ignorespaces}}

该指令可以展开后续的指令，并忽略后面的所有空格：

\begin{codelist}[9.5]{
\newcommand{\truc}{ }
\newcommand{\bidule}{ }

a\truc\bidule b\par
a\ignorespaces\truc\bidule b
}\begin{verbatim}
\newcommand{\truc}{ }
\newcommand{\bidule}{ }

a\truc\bidule b\par
a\ignorespaces\truc\bidule b
\end{verbatim}
\end{codelist}

以上示例中，指令\verb|\truc|和\verb|\bidule|的唯一作用都是在被调用时生成空格。例如，以下指令会生成“\verb*|a { }b|”：

\begin{dmd}
\verb|a\truc\bidule b|
\end{dmd}

也就是说，字母a和b之间由两个空格隔开。调用指令\verb|\ignorespaces|——正如其名——可以忽略指令\verb|\truc|和\verb|\bidule|产生的空格。因此，对于前面的示例，可以使用以下指令：

\begin{dmd}
\begin{verbatim}
\newenvironment{hyperimportant}{% 
    \bfseries\itshape\ignorespaces}{\upshape\mdseries}
\end{verbatim}
\end{dmd}

这样就能删除一个空格：

\renewenvironment{hyperimportant}{% 
    \bfseries\itshape\ignorespaces}{\upshape\mdseries}

\begin{codelist}[9.6]{
    Il est impératif
\begin{hyperimportant}
    de multiplier les sauvegardes
\end{hyperimportant}
de vos documents personnels.
}\begin{verbatim}
Il est impératif
\begin{hyperimportant}
    de multiplier les sauvegardes
\end{hyperimportant}
de vos documents personnels.
\end{verbatim}
\end{codelist}

\subsubsection{指令\dm{\backslash unskip}}

如果细心一些，我们可以发现，“{\bfseries\itshape sauvegardes}”和“de”之间仍然有两个空格抵住了我们的攻击。这就到了\TeX 的原语\verb|\unskip|的用武之地：它可以删除后一个被插入的空格：

\begin{codelist}[9.7]{
    \newcommand{\truc}{ }
\newcommand{\bidule}{ }
a\truc\bidule b\par
a\truc\bidule\unskip b
}\begin{verbatim}
\newcommand{\truc}{ }
\newcommand{\bidule}{ }
a\truc\bidule b\par
a\truc\bidule\unskip b
\end{verbatim}
\end{codelist}

最后，我们环境的“正确”定义如下：

\begin{dmd}
\begin{verbatim}
\newenvironment{hyperimportant}{% 
    \bfseries\itshape\ignorespaces}{\unskip\upshape\mdseries}
\end{verbatim}
\end{dmd}

这样，就可以删除所有我们不希望插入的空格：

\renewenvironment{hyperimportant}{% 
    \bfseries\itshape\ignorespaces}{\unskip\upshape\mdseries}

\begin{codelist}[9.8]{
Il est impératif
\begin{hyperimportant}
  de multiplier les sauvegardes
\end{hyperimportant}
de vos documents personnels.
}\begin{verbatim}
Il est impératif
\begin{hyperimportant}
  de multiplier les sauvegardes
\end{hyperimportant}
de vos documents personnels.
\end{verbatim}
\end{codelist}

\subsection{字符\dm{@}}

在开始探索包的源代码时，你会发现，有很大一部分的指令名称定义中都带有字符\dm{@}。然而，在\dm{.tex}文档中，不允许执行名称带有该字符的指令。这样可以保护或限制包指令的能力范围。例如，在包\textsf{changebar}中定义了指令\verb+\cb@defpoint+，它不能被包的使用者调用。若要重定义该内部指令，需要做出以下小操作：

\begin{dmd}
\begin{verbatim}
\makeatletter
% 我们可以在这里胡说八道
\renewcommand{\@ttention}{oulala...}
\makeatother
% 但在这里就不行了
\end{verbatim}
\end{dmd}

这里举例的指令\verb+\@ttention+只有在字符\dm{@}被当作字母的情况下才能被操作。这正是\verb+\makeatletter+的作用：将字符\dm{@}转化为字母，就像其他字母一样。而指令\verb+\makeatother+可以重新赋予该字符区别于其他字母的特殊性。

\begin{exclamation}
这种操作在使用指令\verb+\usepackage+包含的风格文件中不是必需的。对于这些文件，字符\dm{@}可以当作字母使用。
\end{exclamation}

\TeX 得以更改此字符的类别的方法在10.5.1小节会详细解释。

\subsection{\TeX 的\dm{\backslash let}}

有时，修改\LaTeX 内部的指令以在其默认行为中添加功能是很有用的做法。例如，为了修改内部指令\verb+\bidule+\jz{
    好吧，这并不是一条内部指令。它只是作为愚蠢的例子而使用的指令名称……
}，可以遵循以下步骤。

\begin{enumerate}
    \item 借助\TeX 的指示\verb+\let+保存该指令：
    
    \begin{dmd}
    \verb|\let\biduleORIG\bidule|
    \end{dmd}

    \item 在初始定义的基础上重新定义指令\verb+\bidule+：
    
    \begin{dmd}
    \begin{verbatim}
\renewcommand{\bidule}{%
    一些新东西\biduleORIG}
    \end{verbatim}
    \end{dmd}

    \item 如果有需要，可以借助如下指令重新回到其原定义：
    
    \begin{dmd}
    \verb+\let\bidule\biduleORIG+
    \end{dmd}
\end{enumerate}

\section{控制结构和测试}

包\textsf{ifthen}引入的结构遵循以下语法：

\begin{dmd}
\verb+\ifthenelse{+\codereplace{布尔表达式}\}\\
\{ ……若真，\LaTeX 代码……\}\\
\{ ……若假，\LaTeX 代码……\}
\end{dmd}

以及

\begin{dmd}
\verb+\whiledo{+\codereplace{布尔表达式}\}\\
\{……只要为真时，\LaTeX 代码……\}
\end{dmd}

\codereplace{布尔表达式}可以根据可以由包\textsf{ifthen}中不同指令的上下文构成，具体如下：

\begin{itemize}
    \item 表达式\codereplace{数$_1$}\dm{>}\codereplace{数$_2$}、\codereplace{数$_1$}\dm{<}\codereplace{数$_2$}及\codereplace{数$_1$}\dm{=}\codereplace{数$_2$}都可以用于比较\codereplace{数$_1$}和\codereplace{数$_2$}；
    \item \verb+\equal{+\codereplace{$C_1$}\verb+}{+\codereplace{$C_2$}\dm{\}}可以根据字符串\codereplace{$C_1$}是否等于\codereplace{$C_2$}来返回真或假；
    \item \verb+\isodd{+\codereplace{数}\verb+}+在\codereplace{数}是奇数的时候返回真，否则返回假；
    \item \verb+\value{+\codereplace{计数器}\dm{\}}可以以可被布尔条件使用的形式返回\codereplace{计数器}的值；
    \item \verb+\lengthtest{\codereplace{长度检验}+\dm{\}}返回表达式\codereplace{长度检验}的结果，所谓“长度检验”包含操作符\dm{>}、\dm{<}或\dm{=}和作为运算量的\LaTeX 长度。
\end{itemize}

可以注意到，我们可以使用逻辑连接符\verb+\OR+、\verb+\AND+和\verb+\NOT+，它们在布尔表达式中扮演的正是我们所想象的角色。也可以使用操作符\verb+\(+和\verb+\)+来组合表达式。

\subsection{布尔值和相关操作符}

包\textsf{ifthen}为其朝气蓬勃的用户提供了操作布尔值的方式。可以使用指令\verb+\newboolean+声明一个布尔值：

\begin{dmd}
\verb+\newboolean{+\codereplace{布尔值标识}\}
\end{dmd}

这样就定义了一个可以以\codereplace{布尔值标识}唯一指代的布尔值。接下来，可以使用指令\verb+\setboolean+为其赋值\dm{true}或\dm{false}：

\begin{dmd}
\verb|\setboolean{|\codereplace{布尔值标识}\}\{\codereplace{值}\}
\end{dmd}

当然，可以在控制结构\celan{\S 9.3}中使用以此种方式创建的布尔值，例如：

\begin{dmd}
\verb|\ifthenelse{\boolean{|\codereplace{布尔值标识}\}\}\\
\{……\codereplace{布尔值标识}为真时的\LaTeX 代码……\}\\
\{……\codereplace{布尔值标识}为假时的\LaTeX 代码……\}
\end{dmd}

这里提议了解一下前面内容中的\TeX 版本。实际上，我们可以在\LaTeX 包中找到使用\TeX 编写的代码，特别是对结构“若--则--否则”的使用。如下示例使用了\TeX 定义了新的布尔值\yz{
    其中，imprimante couleur意为“彩色打印机”。
}：

\begin{dmd}
\verb|\newif\ifimprimantecouleur|
\end{dmd}

使用如下指令将其置为假：

\begin{dmd}
\verb|\imprimantecouleurfalse|
\end{dmd}

使用如下指令将其置为真：

\begin{dmd}
\verb|\imprimantecouleurtrue|
\end{dmd}

接下来，就可以在\TeX 模式的结构“若--则--否则”中操作这个布尔值：

\begin{dmd}
\backslash ifimprimantecouleur\\
... \textsl{\% 针对彩色打印机的代码}\\
\backslash else\\
... \textsl{\% 针对黑白打印机的代码}
\end{dmd}

\subsection{示例}

我们希望通过编写指令来生成阶乘函数的展开\jz{
    有人整天没什么事情可做……
}，使得以下方法可以生成预期效果：

\begin{codelist}[9.9]{
    9的阶乘可以表达为：
    \begin{displaymath}
        9!=9\times 8\times 7\times 6\times 5\times 4\times 3\times 2\times 1
    \end{displaymath}
}\begin{verbatim}
9的阶乘可以表达为：
\begin{displaymath}
    9!=\itfactorielle{9}
\end{displaymath}
\end{verbatim}
\end{codelist}

解决该问题的一种方法是，编写一个指令，其中包含循环\verb|\whiledo|：

\begin{dmd}
    \begin{verbatim}
\verb|\newcommand{\itfactorielle}[1]{%
    \setcounter{cptfact}{#1} % 使用一个计数器来存储变量
    \whiledo{\value{cptfact}>1}{ % 只要变量大于1
    \thecptfact\times % 显示一个乘号
    \addtocounter{cptfact}{-1}} % 计数器递减
1} % 在末尾显示1
    \end{verbatim}
\end{dmd}

当然，需要声明计数器：

\begin{dmd}
\verb+\newcounter{cptfact}+
\end{dmd}

可以注意到，在“只要……”循环中的布尔条件中，我们调用了指令\verb|\value|来比较计数器的值和1。更迂回的办法是，我们可以以递归的方式来实现这个指令：

\begin{dmd}
\begin{verbatim}
\newcommand{\recfactorielle}[1]{ % 递归的方式
\setcounter{cptfact}{#1} % 为计数器赋值
\ifthenelse{#1>1}{ % 如果值大于1
    \thecptfact\times % 显示计数器，并紧跟一个乘号
    \addtocounter{cptfact}{-1} % 计数器递减
    \recfactorielle{\thecptfact}} % 做一次递归调用
{1}} % 否则（即值为1）显示1
\end{verbatim}
\end{dmd}

该指令当然与之前的方法生成相同的结果。注意到，在\verb|\ifthenelse|的条件中，我们将一个数（\dm{\#1}）与另一个数（1）作比较。我们也能注意到，\verb|\times|的出现说明了该指令需要在数学模式中执行。如果有需要，我们也可以通过指令\verb|\ensuremath|\celan{\S 4.5.1}来避开这个问题。

在你当前阅读的这个文档中，使用了\verb|\whiledo|\verb|\ifthenelse|来生成表\ref{tab:C.22}，以及第7章中的表??\yz{
    原文此处链接丢失。
}。首先，我们创建了用于以如下形式显示一个符号的指令：

\newcommand{\affsymb}[2]{%
\framebox{% un cadre
\parbox[][16pt][b]{1em}{% autour d’une boîte paragraphe 
\centering% de 16 pt de hauteur, 1em de large,
\Pisymbol{#1}{#2}\\% dont le contenu centré 
\tiny#2}}}

\begin{codelist}[9.10]{
    \affsymb{pzd}{249} \affsymb{pzd}{75}
    \affsymb{pzd}{221} \affsymb{pzd}{88}
}\begin{verbatim}
\affsymb{pzd}{249} \affsymb{pzd}{75}
\affsymb{pzd}{221} \affsymb{pzd}{88}
\end{verbatim}
\end{codelist}

这个指令如下：

\begin{dmd}
\begin{verbatim}
\newcommand{\affsymb}[2]{% 
    \framebox{% un cadre
        \parbox[][16pt][b]{1em}{ % 使用段落字盒框起
        \centering % 字盒高度为16pt，宽度为1em
        \Pisymbol{#1}{#2}\\ % 字盒的内容居中 
        \tiny#2}}} % 字盒的内容由符号和其编号组成
\end{verbatim}
\end{dmd}

