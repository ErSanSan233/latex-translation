\chapter{数学排版}

\begin{epigraphe}{《圣经·马太福音》10:2}
  这十二使徒的名：\\头一个叫西门，又称彼得……
\end{epigraphe}

毫无疑问，\LaTeX 最实用和有趣\jz{
    没错，没错！真的有人排公式纯是为了玩！
}的特性就是可以生成数学公式。它生成的公式自然、美观，并且不需要你做任何工作\jz{
    或者只需要你去做两三件小事情。
}。另外，如果你有使用关于某个特定的公式编辑器点来点去的糟糕记忆，现在就偷着乐吧：现在，编写公式不需要鼠标了！使用\LaTeX 生成公式是一个广大的领域，我们这里仅仅会介绍一些用于生成“常用”公式所需的基本知识。因此，本章仅仅包含操作\LaTeX 公式的简短介绍。

\begin{ii}
\LaTeX 的标准指令足以生成大多数常见的数学方程。然而，建议使用美国数学学会（英：American Mathematical Society）发布的扩展amsmath和amssymb。可以在很多情况下，这两个扩展可以简化格式化过程。
\end{ii}

\section{编写数学公式的两种方式}

\LaTeX 可以识别两种数学公式。第一种是在文本中直接插入公式，就像这样：$ax+b=c$；另一种是将若干公式写在环境中，例如：
$$
{\rm d} U = \delta \mathcal{W} +\delta \mathcal{Q} 
$$

这两种模式都遵循一系列原则，涉及不同符号的字号和位置。如下示例使用了两种模式：

\begin{codelist}[3.1]{
  函数$f(x)$定义如下：
\begin{displaymath}
  f(x)=\sqrt{\frac{x-1}{x+1}}
\end{displaymath}
若其导函数存在，求其导函数。
}
\begin{verbatim}
函数$f(x)$定义如下：
\begin{displaymath}
  f(x)=\sqrt{\frac{x-1}{x+1}}
\end{displaymath}
若其导函数存在，求其导函数。\end{verbatim}
\end{codelist}

这个示例告诉我们，我们可以使用\dm{\$}符号来进入“内部”数学模式，并再次使用\dm{\$}符号退出。此外，这里使用了环境\dm{displaymath}，这是最简单的生成数学式的方法。使用\verb|\[|和\verb|\]|也可以达成后者的效果（参见3.7.1节。）

3.7节会介绍\LaTeX 的不同环境。

\section{常用指令}

\subsection{上标和下标}

正如1.4.1小节提到的，指令\verb|_|和\verb|^|分别可以生成\emph{下标}和\emph{上标}。若需要这两条指令处理多个字符，需要将这些参数“打包”到一组花括号中。

\begin{center}
  \begin{tabular}{lc|lc|lc}
    \verb|x_2| & $x_2$ & \verb|x_{2y}| & $x_{2y}$ & \verb|x_{t_0}| & $x_{t_0}$ \\
    \hline
    \verb|x^2| & $x^2$ & \verb|x^{2y}| & $x^{2y}$ & \verb|x_{t^0}| & $x_{t^0}$ \\
    \hline
    & &  \verb|x^{2y}_{t_0}| & $x^{2y}_{t_0}$ & \verb|x_{t^1}^{2y}| & $x_{t^1}^{2y}$
  \end{tabular}
\end{center}

\subsection{分式和根式}

生成\emph{分式}和\emph{根式}的指令如下：

\begin{itemize}
  \item 指令\verb|\frac{|\codereplace{分子}\verb|}{|\codereplace{分母}\verb|}|可以生成分式，\codereplace{分子}会排在分数线上方，\codereplace{分母}会排在分数线下方；
  \item 指令\verb|\sqrt[|\codereplace{n}\verb|]{|\codereplace{arg}\verb|}|可以生成分式，表示变量\codereplace{arg}的\codereplace{n}次方根。
\end{itemize}

注意，这两种指令在字间模式和方程模式下生成的效果不同。对于分式$\frac{1}{\sin x + 1}$和根式$\sqrt{3x^2-1}$，他们在方程模式下的显示效果为：
\begin{displaymath}
  \frac{1}{\sin x + 1}\quad \sqrt{3x^2-1}
\end{displaymath}

作为介绍这两条指令的结尾，我们来看看它们是如何套用的：

\begin{codelist}[3.2]{
  \begin{displaymath}
    \sqrt{\frac{1+\sqrt[3]{3x+1}}
              {3x+\frac{1-x}{1+x}}}
  \end{displaymath}
}
\begin{verbatim}
\begin{displaymath}
  \sqrt{\frac{1+\sqrt[3]{3x+1}}
             {3x+\frac{1-x}{1+x}}}
\end{displaymath}\end{verbatim}
\end{codelist}

\subsection{符号}

\subsubsection{常用符号}

表\ref{tab:3.1}展示了部分生成你可能需要的符号的宏。

\begin{table}[hbt]
  \centering
  \begin{tabular}{cccccccc}
    \verb+\pm+       & $\pm$  & \verb+\otimes+      &  $\otimes$ & 
    \verb+\cong+     & $\cong$  & \verb+\imath+     &  $\imath$     \\
    \verb+\mp+       & $\mp$  & \verb+\oslash+      &  $\oslash$ &  
    \verb+\subset+   & $\subset$  & \verb+\jmath+   &  $\jmath$     \\
    \verb+\div+      & $\div$  & \verb+\odot+       &  $\odot$     & 
    \verb+\supset+   & $\supset$  & \verb+\ell+     &  $\ell$         \\
    \verb+\ast+      & $\ast$  & \verb+\leq+        &  $\leq$       & 
    \verb+\subseteq+ & $\subseteq$  & \verb+\aleph+ &  $\aleph$     \\
    \verb+\times+    & $\times$  & \verb+\geq+      &  $\geq$       & 
    \verb+\supseteq+ & $\supseteq$  & \verb+\nabla+ &  $\nabla$     \\
    \verb+\bullets+  & $\bullet$  & \verb+\equiv+   &  $\equiv$   & 
    \verb+\in+       & $\in$      & \verb+\|+       &  $\|$         \\
    \verb+\circ+     & $\circ$  & \verb+\ll+        &  $\ll$         & 
    \verb+\ni+       & $\ni$    & \verb+\partial+   &  $\partial$  \\
    \verb+\star+     & $\star$  & \verb+\gg+     &  $\gg$         & 
    \verb+\emptyset+ & $\emptyset$  & \verb+\wedge+ &  $\wedge$     \\
    \verb+\setminus+ & \backslash & \verb+\sim+ &  $\sim$       & %setminus与unicode-math包冲突，会显示空白
    \verb+\forall+   & $\forall$  & \verb+\vee+   &  $\vee$         \\
    \verb+\oplus+    & $\oplus$  & \verb+\simeq+    &  $\simeq$   & 
    \verb+\infty+    & $\infty$  & \verb+\cup+    &  $\cup$         \\
    \verb+\ominus+   & $\ominus$  & \verb+\approx+   &  $\approx$ & 
    \verb+\exists+   & $\exists$  & \verb+\cap+   &  $\cap$   
  \end{tabular}
  \caption{常用数学符号}
  \label{tab:3.1}
\end{table}

\begin{ii}
我们盘点了latexsym和amssymb包中的近450个符号（参见附录C）%TODO
。目的不是介绍它们！表\ref{tab:3.1}是标准符号中的一部分，我们认为它们可能是最常用的那一批——除了完全偶然出现的$\aleph$\yz{
  aleph，希伯来文字母表的第一个字母。
}。也许这证明了作者的数学水平不太高。
\end{ii}

\subsubsection{省略号}

为了节省篇幅，数学式中经常使用省略号。省略号有三种，指令\verb|\dots|可以生成点“放置在”基线上的省略号：

\begin{codelist}[3.3]{
$C=\{\vec{c}_0,\vec{c}_1,\dots,
    \vec{c}_N\}$
为$N$个颜色的集合。
}
\begin{verbatim}
$C=\{\vec{c}_0,\vec{c}_1,\dots,
    \vec{c}_N\}$
为$N$个颜色的集合。\end{verbatim}
\end{codelist}

指令\verb|\cdots|生成的省略号圆点上下居中，就像等号一样：

\begin{codelist}[3.4]{
  $\vec{\mu}=\frac{1}{N}
(\vec{c}_0+\vec{c}_1+\cdots+\vec{c}_N)$
为$N$个颜色的平均值。
}
\begin{verbatim}
$\vec{\mu}=\frac{1}{N}
(\vec{c}_0+\vec{c}_1+\cdots+\vec{c}_N)$
为$N$个颜色的平均值。\end{verbatim}
\end{codelist}

最后，指令\verb|\vdots|和\verb|\ddots|主要在矩阵中使用（参见3.6节、例3.15）。这两个指令分别可以生成$\vdots$和$\ddots$这两种省略号。

\subsubsection{箭头}

用于生成箭头的指令可以使用以下简单的方法来记忆：

\begin{itemize}
  \item 所有指令均以\dm{arrow}结尾；
  \item 必须带有前缀\dm{left}或\dm{right}，表示方向；
  \item 可以带有前缀\dm{long}，表示加长；
  \item 指令的第一个字母可以改为大写，表示箭头使用双线；
  \item 可以连写\dm{left}和\dm{right}，表示双向箭头。
\end{itemize}

综上：

\begin{center}
  \begin{tabular}{lll|lll}
    \verb+\rightarrow+ & 表示  &$\rightarrow$ &
    \verb+\Longleftarrow+ & 表示 & $\Longleftarrow$ \\
    \verb+\Leftarrow+ & 表示 &$\Leftarrow$ &
    \verb+\Longleftrightarrow+ & 表示 &$\Longleftrightarrow$
  \end{tabular}
\end{center}

\subsubsection{希腊字母}

可以以一种极简单的方式使用希腊字母：打出它们的名字。也就是说，\verb|\alpha|表示$\alpha $，\verb|\pi|表示$\pi $。将指令的第一个字母改为大写，表示将对应希腊字母改为大写：\verb|\Gamma|表示$\Gamma $。注意，不是所有大写希腊字母都有对应的指令，如果要将$\alpha $改为大写，直接使用字母A即可（指令\verb|\Alpha|不存在）。

\subsubsection{实数集}

科技文档的作者常常会面临一个“至关重要”的问题：“我们应当如何打出代表实数集的字母`R'？”关于这个问题，这里分享几个观点。从历史上看，似乎最初的数学资料上将实数符号排版为加粗的形式（“令$x \in \mathbf{R}$”），老师们会使用粉笔反复在字母“R”上描几遍，来代表这个符号。这种比较烦琐的方法促成了我们“更熟悉”的写法：“令$x \in \mathbbm{R}$”。因此，出现了不同的流派：$\mathbf{R}$、ℝ，等等。如果你想自己选择，那么有如下包和指令供你选择：

\begin{itemize}
  \item \textsf{bbm}提供的指令\verb|\mathbbm{R}|可以生成$\mathbbm{R}$、指令\verb|\mathbbmss{R}|可以生成$\mathbbmss{R}$，等等；
  \item \textsf{bbold}提供的指令\verb|\mathbbm{R}|可以生成$\mathbbm{R}$；
  \item \textsf{amssymb}提供的指令\verb|\mathbb{R}|可以生成ℝ、指令\verb|\mathbf{R}|可以生成$\mathbf{R}$。
\end{itemize}

\section{函数}

\subsection{标准函数}

要生成经典的数学函数（如对数函数、三角函数等），需要使用\LaTeX 预装的函数来实现，这里是一个示例：

\begin{codelist}[3.5]{
$\sin^2x + \cos^2 x=1$
}
\begin{verbatim}
$\sin^2x + \cos^2 x=1$\end{verbatim}
\end{codelist}

如果不使用\LaTeX 函数：

\begin{codelist}[3.6]{
$sin^2x + cos^2x=1$
}
\begin{verbatim}
$sin^2x + cos^2x=1$\end{verbatim}
\end{codelist}

二者的区别在于，\LaTeX 会将字符串\dm{cos}视为一系列变量（因此生成意大利体），而将函数\verb|\cos|生成为罗马体的“cos”。另一个区别是对可能存在的下标的处理（参见以下\verb|\max|的示例）。以下函数都是\LaTeX 的标准数学函数。

\begin{itemize}
  \item 各种三角函数：\verb|\sin|、\verb|\cos|、\verb|\tan|。在前面加\dm{arc}，可以得到对应的反函数。在后面加\dm{h}，可以得到双曲三角函数。
  \item 自然对数和常用对数\yz{
    指以10为底的对数，标准的写法为$\lg$。本书以原书习惯为准，约定使用$\log$。
  }分别使用函数\verb|\ln|和\verb|\log|。
  \item 函数\verb|\sup|、\verb|\inf|、\verb|\max|、\verb|\min|、\verb|\arg|可以用于如下形式的数学式中：
  
  \begin{codelist}[3.7]{
    \begin{displaymath}
      T=\arg \max_{t<0} f(t)
    \end{displaymath}
  }
\begin{verbatim}
\begin{displaymath}
  T=\arg \max_{t<0} f(t)
\end{displaymath}
  \end{verbatim}
  \end{codelist}
\end{itemize}

注意搭配\verb|\max|使用下标操作符\dm{\_}的结果。

\subsection{积分、求和和其他极限}

\LaTeX 使用一套简单的语法来生成\emph{积分}、\emph{求和}等内容，具体如下：

\begin{dmd}
\backslash \codereplace{操作}\verb|_{|\codereplace{下界}\verb|}^{|\codereplace{上界}\verb|}|
\end{dmd}

其中\codereplace{操作}可以是\dm{sum}、\dm{prod}、\dm{int}、\dm{lim}之一，\codereplace{上界}和\codereplace{下界}会排列在操作符号的周围。例如：

\begin{codelist}[3.8]{
  对此等比数列求和：
\begin{displaymath}
  \sum_{i=0}^{n}q^i=
  \frac{\quad 1-q^{n+1}}{1-q}
\end{displaymath}
}
\begin{verbatim}
  对此等比数列求和：
\begin{displaymath}
  \sum_{i=0}^{n}q^i=
  \frac{1-q^{n+1}}{1-q}
\end{displaymath}\end{verbatim}
\end{codelist}

类似地，使用指令\verb|\prod|可以生成求积符号$\prod$。
以下是使用积分的示例：

\begin{codelist}[3.9]{
对于$x>0$，定义自然对数如下：
\begin{displaymath}
  \ln(x)=\int_{1}^{x}\frac{1}{t}
  \,\mathrm{dt}
\end{displaymath}
}
\begin{verbatim}
对于$x>0$，定义自然对数如下：
\begin{displaymath}
  \ln(x)=\int_{1}^{x}\frac{1}{t}
  \,\mathrm{dt}
\end{displaymath}\end{verbatim}
\end{codelist}

指令\verb|\,|可以在“dt”前插入很小的空格（参见3.5.1小节）。你如果更喜欢\emph{线积分}，可以使用\verb|\oint|，这个指令可以生成符号$\oint$。好了，这里会给出一个关于极限的示例，相信你可以看懂：

\begin{codelist}[3.10]{
  $f(x)$在$x_0$处存在极限$\ell$：
\begin{displaymath}
  \lim_{x\rightarrow x_0}f(x)=\ell
\end{displaymath}
}
\begin{verbatim}
$f(x)$在$x_0$处存在极限$\ell$：
\begin{displaymath}
  \lim_{x\rightarrow x_0}f(x)=\ell
\end{displaymath}\end{verbatim}
\end{codelist}

希望你能注意到示例中漂亮的$\ell$。为了巩固一下关于两种数学模式的知识，这里给出相同的数学式，但它们这次会镶嵌在行文中：求和，$\sum_{i=0}^{n}q^i=\frac{1-q^{n+1}}{1-q}$；求积分，$\ln(x)=\int_{1}^{x}\frac{1}{t}\,\mathrm{dt}$；求极限，$\lim_{x\rightarrow x_0}f(x)=\ell$。

\section{重叠的符号}

\subsection{操作符\dm{not}}

操作符\verb|\not|可以生成特定关系的“否定”样式：

\begin{codelist}[3.11]{
  令实数$x \not\in I$……
}
\begin{verbatim}
  令实数$x \not\in I$……\end{verbatim}
\end{codelist}

\verb|\not|的输出结果就是在其下一个符号上加上一道“斜杠”。\textbf{注意}，这个操作符并不能总是呈现出完美的效果，例如\verb|$\not\longrightarrow$|会显示为$\not\longrightarrow$。但对于宽度合适的符号，它给出的结果还能令人满意。

\subsection{“变音符号”}

对于特殊的数学概念，经常需要\jz{
  实际上，一些名副其实的大数学家很喜欢这种符号上面的小帽子。一些人甚至还喜欢在上面叠两层、三层……
}在符号上加“变音”符号。以下是可用的符号示例：

\begin{center}
  \begin{tabular}{lc@{\quad}lc@{\quad}lc}
    \verb+\hat{x}+  &$\hat{x}$  & \verb+\check{x}+&$\check{x}$&
    \verb+\breve{x}+&$\breve{x}$\\
    \verb+\acute{x}+&$\acute{x}$& \verb+\grave{x}+&$\grave{x}$&
    \verb+\tilde{x}+&$\tilde{x}$\\ 
    \verb+\bar{x}+  &$\bar{x}$  & \verb+\dot{x}+&$\dot{x}$&
    \verb+\ddot{x}+ &$\ddot{x}$\\  
  \end{tabular}
\end{center}


\subsection{向量}

有两种\jz{
由埃迪·索德雷（Eddie Saudrais）开发的包\textsf{esvect}可以为向量生成更好看的箭头。
}方式可以得到向量：

\begin{itemize}
  \item 对于小些的符号，可以使用\verb|\vec|，因为这个指令是用于添加“变音”符号的。
  \item 对于其他情况，可以使用\verb|\overrightarrow|。
\end{itemize}

\begin{codelist}[3.12]{
设$\overrightarrow{A\!B}$在基底
$(\vec{\imath},\vec{\jmath})$
下定义。
}
\begin{verbatim}
设$\overrightarrow{A\!B}$在基底
$(\vec{\imath},\vec{\jmath})$
下定义。\end{verbatim}
\end{codelist}

注意，\verb|$\vec{A\!B}$|会显示为$\vec{A\!B}$（关于\verb|\!|的用途，参见3.5.1小节）。此外，指令\verb|\imath|和\verb|\jmath|分别可以生成不带点的字母i和j：$\imath$、$\jmath$。

\subsection{指令\dm{stackrel}}

指令\verb|\stackrel|可以将两个符号叠放在一起：

\begin{dmd}
\verb|\stackrel{|\codereplace{符号$_1$}\}\{\codereplace{符号$_2$}\}
\end{dmd}

\codereplace{符号$_1$}会置于\codereplace{符号$_2$}上方。例如：

\begin{dmd}
\verb|x\stackrel{f}{\longmapsto}y|
\end{dmd}

以上代码会生成$x\stackrel{f}{\longmapsto}y$。

\section{两个重要原则}

为了掌握\LaTeX 生成数学式的方法，需要知道以下两个原则。

\begin{description}
  \item[空格] \LaTeX 会忽略数学式中夹带的空格，因此\verb|$x+1$|和\verb|$x + 1$|生成的结果是相同的。\LaTeX 会在它认为最合适的地方添加空格。
  \item[文本] 任何的符号组都会被当作同一系列变量或函数对待，因此\verb|$x=t avec t>0$|\yz{
    此问题几乎只在西文排版中出现，因此保留原文。avec可理解为“且其中”。
  }会生成“$x=t avec t>0$”，而不是你所期待的“$x=t$ avec $t>0$”
  \jz{
    数学式中夹带文本的问题只会在使用\dm{displaymath}系列的环境时显现出来。毕竟，使用“\dm{\$x=t\$ avec \$t>0\$}”总是可以的！
  }。
\end{description}

在了解了两个原则后，来看看入门如何处理相关的问题。

\subsection{数学模式的空格}

首先需要知道，\LaTeX 选择添加空格的方式一般是正确的。然而，如果有一天你非要去\linebreak\rlap{ㄨㄨㄨㄨ}吹毛求疵，表\ref{tab:3.2}可以帮助你在数学式中插入空格。在该表格中，我们在两个$\Box$符号之间夹入不同的空格指令，来展示它们的效果。

\begin{table}[ht]
  \begin{center}
    \begin{tabular}{|ll|ll|ll|ll|}
      \hline
      \verb+\!+ & $\Box\!\Box$ &
      \emph{无指令} & $\Box\Box$ &
      \verb+\,+ & $\Box\,\Box$ &
      \verb+\:+ & $\Box\:\Box$ \\
      \hline
      \verb+\;+ & $\Box\;\Box$ &
      \verb*+\ + & $\Box\ \Box$ &
      \verb|\quad| & $\Box\quad\Box$ &
      \verb|\qquad| & $\Box\qquad\Box$ \\
      \hline
    \end{tabular}
    \caption{数学模式中的空格}
    \label{tab:3.2}
  \end{center}
\end{table}

对于那些关注“毛”“疵”的人，要强调一下，本书在等比数列的示例（参见3.3.2小节）中偷偷了在分子上添加了一些空格，以让分式中的两个$q$稍微对齐。如果按照默认的生成方式，结果会是这样的：

\begin{displaymath}
  \sum_{i=0}^{n}q^i=
  \frac{1-q^{n+1}}{1-q}
\end{displaymath}

不知道这个关于$q$的故事是否为你带来了更敏锐的观察力。

\subsection{数学模式中的文本}

在数学式中插入文本，最简单的方法是将文本“装箱”，并适当地插入空格：

\begin{codelist}[3.13]{
设数列$(u_n),(v_n)$：
\begin{displaymath}
  u_n=\ln n\quad
  \mbox{且}\quad v_n=(1+\frac{1}{n})^n
  \label{ex-maths-suite}
\end{displaymath}
}
\begin{verbatim}
设数列$(u_n),(v_n)$：
\begin{displaymath}
  u_n=\ln n\quad
  \mbox{且}\quad v_n=(1+\frac{1}{n})^n
  \label{ex-maths-suite}
\end{displaymath}\end{verbatim}
\end{codelist}

你可以在4.4.1小节找到关于指令\verb|\mbox|的细节。如果你已经在考虑使用包\textsf{amsmath}，相比于使用\verb|\mbox|，也可以考虑使用指令\verb|\text|。

\section{阵列（array）：简单且高效}

阵列环境\dm{array}可以满足生成大多数数学式的需求。正如其名，它可以将对象排列成一行行、一列列的样子。实际上，它和环境\dm{tabular}对应。也正如\dm{tabular}一样，\dm{array}也不会换行。

\subsection{阵列的原理}

关于阵列环境的语法，可以回忆一下\dm{tabular}，有：

\begin{dmd}
\verb|\begin{array}[|\codereplace{垂直位置}]\{\codereplace{格式}\verb|} ... \end{array}|
\end{dmd}

其中，\codereplace{格式}指明各列的对齐方式：\dm{c}表示居中，\dm{l}表示左对齐，\dm{r}表示右对齐。可选的参数\codereplace{垂直位置}可以明确整个表格的垂直位置\celan{\S 2.2.4}。与表格中相同，我们使用以下指令：

\begin{itemize}
  \item 使用\verb|&|分隔不同列；
  \item 使用\verb|\\|换行。
\end{itemize}

\begin{codelist}[3.14]{
  设$A=\begin{array}{rc}
    -1&1\\
    3&4
  \end{array}$为数字阵列……
}
\begin{verbatim}
设$A=\begin{array}{rc}
  -1&1\\
  3&4
\end{array}$为数字阵列……\end{verbatim}
\end{codelist}

以下示例使用了省略号：

\begin{codelist}[3.15]{
  \begin{displaymath} A=\left[\begin{array}{ccc}
    a_{00} & \dots & a_{0n}\\
    \vdots & \ddots & \vdots\\
    a_{n0} & \dots & a_{nn}
  \end{array}\right]\end{displaymath}
}
\begin{verbatim}
\begin{displaymath} A=\left[\begin{array}{ccc}
  a_{00} & \dots & a_{0n}\\
  \vdots & \ddots & \vdots\\
  a_{n0} & \dots & a_{nn}
\end{array}\right]\end{displaymath}\end{verbatim}
\end{codelist}

\subsection{阵列和定界符号}

我们经常需要\dm{array}来生成矩阵，这需要借助\emph{定界符号}的辅助。定界符号是一类特殊的括号，可能是方括号、花括号等，可以将数学对象包裹其中。其语法如下：

\begin{dmd}
\verb|\left|\codereplace{定界$_1$} \codereplace{对象} \verb|\right|\codereplace{定界$_2$}
\end{dmd}

其中，\codereplace{定界$_1$}和\codereplace{定界$_2$}为定界符号，\codereplace{对象}为其包裹的数学对象。

较常用的定界符号如下：

\begin{center}
  \begin{tabular}{cccc}
    \verb+(+ 和 \verb+)+               & $(\Pi)$             &
    \verb+[+ 和 \verb+]+               & $[\Pi]$             \\
    \verb+\{+ 和 \verb+\}+             & $\{\Pi\}$           &
    \verb|\lfloor| 和 \verb|\rfloor| & $\lfloor\Pi\rfloor$ \\
    \verb|\lceil| 和 \verb|\rceil|   & $\lceil\Pi\rceil$   &
    \verb|\langle| 和 \verb|\rangle| & $\langle\Pi\rangle$  \\
    \verb+|+                           & $|\Pi|$             &
    \verb+\|+                         & $\|\Pi\|$           
  \end{tabular}
\end{center}

使用定界符号的好处是，这种符号可以自动适应它包裹的对象的尺寸：

\begin{codelist}[3.16]{
  设$I=
\left[\begin{array}{cc}
  1&0\\0&1
\end{array}\right]$
为单位矩阵。
}
\begin{verbatim}
设$I=
\left[\begin{array}{cc}
  1&0\\0&1
\end{array}\right]$
为单位矩阵。\end{verbatim}
\end{codelist}

我们同样可以使用定界符号重写示例3.13，来改变括号的尺寸：

\begin{codelist}[3.17]{
  设数列$(u_n),(v_n)$：
\begin{displaymath}
  u_n=\ln n\quad\mbox{et}
  \quad v_n=\left(1+\frac{1}{n}\right)^n
\end{displaymath}
}
\begin{verbatim}
设数列$(u_n),(v_n)$：
\begin{displaymath}
  u_n=\ln n\quad\mbox{et}
  \quad v_n=\left(1+\frac{1}{n}\right)^n
\end{displaymath}\end{verbatim}
\end{codelist}

\begin{exclamation}
对于每一个指令\verb|\left|，都应该有一个指令\verb|\right|与其对应。然而，左侧和右侧分别使用的符号不必是配套的。
\end{exclamation}

以下示例中使用了\verb|\right.|，表示我们不需要右侧的符号：

\begin{codelist}[3.18]{
  设$ S_i=\left\{\begin{array}{rl}
    -1  & \mbox{若$i$为偶数，}    \\
    1  & \mbox{否则。}
  \end{array}\right.$
}
\begin{verbatim}
设$ S_i=\left\{\begin{array}{rl}
  -1  & \mbox{若$i$为偶数，}    \\
  1  & \mbox{s否则。}
\end{array}\right.$\end{verbatim}
\end{codelist}

\subsection{说话的方式简单点……}

包\textsf{amsmath}中提供了两种环境——\verb|pmatrix|（p代表parenthèse，即圆括号）和\verb|bmatrix|（b代表英文的\emph{braket}，即方括号），可以简单地插入矩阵：

\begin{codelist}[3.19]{
  \begin{displaymath}
    \bar{\bar{\sigma}}=\begin{bmatrix}
      \sigma_{11} & \sigma_{12} \\
      \sigma_{21} & \sigma_{22} \\
    \end{bmatrix}
  \end{displaymath}
}
\begin{verbatim}
\begin{displaymath}
  \bar{\bar{\sigma}}=\begin{bmatrix}
    \sigma_{11} & \sigma_{12} \\
    \sigma_{21} & \sigma_{22} \\
  \end{bmatrix}
\end{displaymath}\end{verbatim}
\end{codelist}

\section{方程和环境}

本节会介绍\LaTeX 中可以生成数学式的三种标准环境。

\subsection{环境\dm{displaymath}}

你如果已经阅读到这里，应该已经明白，\dm{displaymath}可以打断当前段落，并居中显示一行公式。\verb|\begin{displaymath}...\end{displaymath}|的一种简略的写法是：
\verb|\[...\]|。例如：

\begin{codelist}[3.20]{
  色度距离：\[
  \Delta E=\sqrt{
   \Delta L^{*2}+ \Delta a^{*2}
  +\Delta b^{*2}} \]
}
\begin{verbatim}
色度距离：\[
  \Delta E=\sqrt{
   \Delta L^{*2}+ \Delta a^{*2}
  +\Delta b^{*2}} \]\end{verbatim}
\end{codelist}

\subsection{方程环境\dm{equation}}

方程环境\dm{equation}的作用与\dm{displaymath}相同，但可以为数学式编号：

\begin{codelist}[3.21]{
  请牢记，若$a>0$且$b>0$，有
\begin{equation}
  \ln(ab)=\ln(a)+\ln(b)
\end{equation}
}
\begin{verbatim}
请牢记，若$a>0$且$b>0$，有
\begin{equation}
  \ln(ab)=\ln(a)+\ln(b)
\end{equation}\end{verbatim}
\end{codelist}

\begin{ii}
文档类中的选项\dm{leqno}可以将方程的编号放在左侧。方程环境的选项\dm{fleqn}可以将方程居左，而非居中显示。
\end{ii}

\subsection{多行数学式}

\begin{ii}
在本书的某个旧版本中，作为介绍标准环境的结尾，我们曾引入环境\dm{eqnarray}。这个环境可以生成多行数学式，但\textbf{要知道这是错误的}。关于这个话题，有一些资料（如[12]或[14]）会向你解释如何生成“正确”的文档。要坚定不移地相信，使用\dm{eqnarray}（以及很多其他工具）\textbf{是在造孽}。无论如何，如果你没有禁住诱惑而向\dm{eqnarray}让步，那么终有一天，审判会顺着搜索引擎降临，任何忏悔都将无济于事，任何赦免都将无法拯救你。勿谓言之不预也。
\end{ii}

我们在此介绍包\textsf{amsmath}中的环境\dm{align}：

\begin{itemize}
  \item 使用\verb|\\|换行；
  \item 每行数学式都会编号，除非指令\verb|\nonumber|出现在该行中；
  \item 使用两个操作符\verb|&|\jz{
    因为共有三列。（\textsl{译注}：原文如此。）
  }来对齐。
\end{itemize}

\begin{codelist}[3.22]{
\begin{align}%TODO align会产生奇怪的空行
  (a+b)^2 & =  (a+b)(a+b)\nonumber\\
          & =  a^2+b^2+2ab
  \end{align}
}
\begin{verbatim}
\begin{align}
  (a+b)^2 & =  (a+b)(a+b)\nonumber\\
          & =  a^2+b^2+2ab
\end{align}\end{verbatim}
\end{codelist}

\begin{ii}
带有星号的环境\dm{align*}可以使所有行都不编号。要想引用环境\dm{align}中的多行，需要插入同样数量的\verb|\label|，分别对应相应行。
\end{ii}

若要为占用多行的方程编号，可以使用环境\dm{split}（同样由\textsf{amsmath}提供）：

\begin{codelist}[3.23]{
  \begin{equation}
    \begin{split}
      (a+b)^2 & =  (a+b)(a+b)\\
      & =  a^2+b^2+2ab
    \end{split}
  \end{equation}
}
\begin{verbatim}
\begin{equation}
  \begin{split}
    (a+b)^2 & =  (a+b)(a+b)\\
    & =  a^2+b^2+2ab
  \end{split}
\end{equation}\end{verbatim}
\end{codelist}

\section{数学模式的风格}

\subsection{字体}

\LaTeX 支持多种用于在数学模式中切换字体的指令\yz{
  本节疑似原书作者的包和译稿使用的xeCJK都有冲突，仅针对使用法文书写的环境。此小节暂时按原文誊写。% todo conflict
}。默认情况下，所有符号或字符序列（除了特定函数）在最终文档中都会以意大利体呈现。在一些情况下，强制切换字体风格会很有用。实现方法具体如下：

\begin{center}
  \begin{tabular}{ll}
    \verb|设$\mathit{A\in\Phi}$| & 设$\mathit{A\in Φ}$\\
    \verb|设$\mathrm{A\in\Phi}$| & 设$\mathrm{A\in Φ}$\\
    \verb|设$\mathbf{A\in\Phi}$| & 设$\mathbf{A\in Φ}$\\
    \verb|设$\mathsf{A\in\Phi}$| & 设$\mathsf{A\in Φ}$\\
    \verb|设$\mathtt{A\in\Phi}$| & 设$\mathtt{A\in Φ}$\\
    \verb|设$\mathcal{A\in\Phi}$| & 设$\mathcal{A\in\Phi}$\\
  \end{tabular}
\end{center}

\begin{exclamation}
指令\verb|\mathcal|只接受大写拉丁字母作为变量，否则结果会展示为乱码。例如：\\
\verb|\mathcal{abcd\Gamma}|

上述指令的运行结果为$\dashv \lfloor \rfloor \lceil -$。
\end{exclamation}

\subsection{符号的字号}

\LaTeX 会区分四种数学式写作\emph{风格}。\LaTeX 生成数学式时，会根据当前的“处境”选择模式。

\begin{description}
  \item[文本] 适用于行文间插入的数学式。
  \item[方程] 适用于\emph{方程}格式下的数学式。
  \item[角标] 适用于角标。
  \item[子角标] 适用于角标的角标。 
\end{description}

每种模式都可以明确地使用以下声明激活：

\begin{itemize}
  \item 使用\verb|\textstyle|切换文本模式；
  \item 使用\verb|\displaystyle|切换方程模式；
  \item 使用\verb|\scriptstyle|切换角标模式；
  \item 使用\verb|\scriptscriptstyle|切换子角标模式；
\end{itemize}

以下示例阐明了如何在\emph{方程}模式中强制使用\emph{文本}模式，以及相反的操作：

\begin{codelist}[3.24]{
两种形式的积：$\prod_{1}^{n}f_i$
和$\displaystyle\prod_{1}^{n}f_i$
相反操作：
\[ \prod_{1}^{n}f_i
\mbox{ 和 }\textstyle\prod_{1}^{n}f_i \]
}
\begin{verbatim}
两种形式的积：$\prod_{1}^{n}f_i$
和$\displaystyle\prod_{1}^{n}f_i$
相反操作：
\[ \prod_{1}^{n}f_i
\mbox{ 和 }\textstyle\prod_{1}^{n}f_i \]\end{verbatim}
\end{codelist}

\subsection{创建新操作符}

想象在一个场景中，你需要创建一个特殊的操作符，称作“burps”。只需要通过如下形式生成：

\begin{codelist}[3.25]{
\newcommand{\burps}{
\mathop{\textrm{burps}}}
$x=\burps_i f(i)$
}
\begin{verbatim}
\newcommand{\burps}{
\mathop{\textrm{burps}}}
$x=\burps_i f(i)$\end{verbatim}
\end{codelist}

再看一个例子。为了让“反正弦函数”（默认显示为arcsin）依法国的习惯显示，可以按如下示例操作：

\begin{codelist}[3.26]{
  $\theta = \arcsin x$
\renewcommand{\arcsin}{%
  \mathop{\textrm{Arcsin}}\nolimits}
$\theta = \arcsin x$
}
\begin{verbatim}
$\theta = \arcsin x$
\renewcommand{\arcsin}{%
  \mathop{\textrm{Arcsin}}\nolimits}
$\theta = \arcsin x$\end{verbatim}
\end{codelist}

指令\verb|\nolimits|可以使相关操作符不再将参数显示为上标或下标的形式，正如操作符\verb|\lim|、\verb|\int|等所做的那样\yz{
  此句疑似说反了。
}。此外，前文的两个示例使用了指令\verb|\newcommand|和\verb|\renewcommand|，相关问题请参见4.5节。

最后，还有一种方式可以达到类似的目的。如果你已经加载了\textsf{amsmath}包，并在文前部分进行了以下声明：

\begin{dmd}
\verb|\DeclareMathOperator*{\vlunch}{vlunch}|
\verb|\DeclareMathOperator{\zirgl}{Zirgl}|
\end{dmd}

那么可以实现以下操作：

\begin{codelist}[3.27]{
  \[
  x=\mathop{\rm vlunch}\limits_{i} f(\theta)
  \]
  其中$\theta =$ Zirgl $y$。
}
\begin{verbatim}
\[x=\vlunch_i f(\theta)\]
其中$\theta = \zirgl y$。\end{verbatim}
\end{codelist}

\section{小结}

本章介绍了用于生成数学式的基本方程。对于大多数科学文档，这些指令已经足够使用了。如果你不得不起草一份充斥这复杂数学式的文档，仅靠\LaTeX 的宏可能不能满足需求。因此，著名的\emph{美国数学协会（英：American Mathematical Society）}孵化了称为\AmS\TeX 的包（通过\verb|\usepackage{amsmath}|使用），可以生成尤其“奇形怪状”的数学式。