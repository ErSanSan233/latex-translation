\chapter{数学排版}

这十二使徒的名：头一个叫西门，又称彼得……——《圣经·马太福音》10:2

毫无疑问，\LaTeX 最实用和有趣\jz{
    没错，没错！真的有人排公式纯是为了玩！
}的特性就是可以生成数学公式。它生成的公式自然、美观，并且不需要你做任何工作\jz{
    或者只需要你去做两三件小事情。
}。另外，如果你有使用关于某个特定的公式编辑器点来点去的糟糕记忆，现在就偷着乐吧：现在，编写公式不需要鼠标了！使用\LaTeX 生成公式是一个广大的领域，我们这里仅仅会介绍一些用于生成“常用”公式所需的基本知识。因此，本章仅仅包含操作\LaTeX 公式的简短介绍。

\begin{ii}
\LaTeX 的标准指令足以生成大多数常见的数学方程。然而，建议使用美国数学学会（英：American Mathematical Society）发布的扩展amsmath和amssymb。可以在很多情况下，这两个扩展可以简化格式化过程。
\end{ii}

\section{编写数学公式的两种方式}

\LaTeX 可以识别两种数学公式。第一种是在文本中直接插入公式，就像这样：$ax+b=c$；另一种是将若干公式写在环境中，例如：
$$
{\rm d} U = \delta \mathcal{W} +\delta \mathcal{Q} 
$$

这两种模式都遵循一系列原则，涉及不同符号的字号和位置。如下示例使用了两种模式：

\begin{codelist}[3.1]{
  函数$f(x)$定义如下：
\begin{displaymath}
  f(x)=\sqrt{\frac{x-1}{x+1}}
\end{displaymath}
若其导函数存在，求其导函数。
}\begin{verbatim}
函数$f(x)$定义如下：
\begin{displaymath}
  f(x)=\sqrt{\frac{x-1}{x+1}}
\end{displaymath}
若其导函数存在，求其导函数。
\end{verbatim}
\end{codelist}

这个示例告诉我们，我们可以使用\dm{\$}符号来进入“内部”数学模式，并再次使用\dm{\$}符号退出。此外，这里使用了环境\dm{displaymath}，这是最简单的生成数学式的方法。使用\verb|\[|和\verb|\]|也可以达成后者的效果（参见3.7.1节。）

3.7节会介绍\LaTeX 的不同环境。

\section{常用指令}

\subsection{上标和下标}

正如1.4.1小节提到的，指令\verb|_|和\verb|^|分别可以生成\emph{下标}和\emph{上标}。若需要这两条指令处理多个字符，需要将这些参数“打包”到一组花括号中。

\begin{center}
  \begin{tabular}{lc|lc|lc}
    \verb|x_2| & $x_2$ & \verb|x_{2y}| & $x_{2y}$ & \verb|x_{t_0}| & $x_{t_0}$ \\
    \hline
    \verb|x^2| & $x^2$ & \verb|x^{2y}| & $x^{2y}$ & \verb|x_{t^0}| & $x_{t^0}$ \\
    \hline
    & &  \verb|x^{2y}_{t_0}| & $x^{2y}_{t_0}$ & \verb|x_{t^1}^{2y}| & $x_{t^1}^{2y}$
  \end{tabular}
\end{center}

\subsection{分式和根式}

生成\emph{分式}和\emph{根式}的指令如下：

\begin{itemize}
  \item 指令\verb|\frac{|\codereplace{分子}\verb|}{|\codereplace{分母}\verb|}|可以生成分式，\codereplace{分子}会排在分数线上方，\codereplace{分母}会排在分数线下方；
  \item 指令\verb|\sqrt[|\codereplace{n}\verb|]{|\codereplace{arg}\verb|}|可以生成分式，表示变量\codereplace{arg}的\codereplace{n}次方根。
\end{itemize}

注意，这两种指令在字间模式和方程模式下生成的效果不同。对于分式$\frac{1}{\sin x + 1}$和根式$\sqrt{3x^2-1}$，他们在方程模式下的显示效果为：
\begin{displaymath}
  \frac{1}{\sin x + 1}\quad \sqrt{3x^2-1}
\end{displaymath}

作为介绍这两条指令的结尾，我们来看看它们是如何套用的：

\begin{codelist}[3.2]{
  \begin{displaymath}
    \sqrt{\frac{1+\sqrt[3]{3x+1}}
              {3x+\frac{1-x}{1+x}}}
  \end{displaymath}
}\begin{verbatim}
\begin{displaymath}
  \sqrt{\frac{1+\sqrt[3]{3x+1}}
             {3x+\frac{1-x}{1+x}}}
\end{displaymath}
\end{verbatim}
\end{codelist}

\subsection{符号}

\subsubsection{常用符号}

表\ref{tab:3.1}展示了部分生成你可能需要的符号的宏。

\begin{table}[hbt]
  \centering
  \begin{tabular}{cccccccc}
    \verb+\pm+       & $\pm$  & \verb+\otimes+      &  $\otimes$ & 
    \verb+\cong+     & $\cong$  & \verb+\imath+     &  $\imath$     \\
    \verb+\mp+       & $\mp$  & \verb+\oslash+      &  $\oslash$ &  
    \verb+\subset+   & $\subset$  & \verb+\jmath+   &  $\jmath$     \\
    \verb+\div+      & $\div$  & \verb+\odot+       &  $\odot$     & 
    \verb+\supset+   & $\supset$  & \verb+\ell+     &  $\ell$         \\
    \verb+\ast+      & $\ast$  & \verb+\leq+        &  $\leq$       & 
    \verb+\subseteq+ & $\subseteq$  & \verb+\aleph+ &  $\aleph$     \\
    \verb+\times+    & $\times$  & \verb+\geq+      &  $\geq$       & 
    \verb+\supseteq+ & $\supseteq$  & \verb+\nabla+ &  $\nabla$     \\
    \verb+\bullets+  & $\bullet$  & \verb+\equiv+   &  $\equiv$   & 
    \verb+\in+       & $\in$      & \verb+\|+       &  $\|$         \\
    \verb+\circ+     & $\circ$  & \verb+\ll+        &  $\ll$         & 
    \verb+\ni+       & $\ni$    & \verb+\partial+   &  $\partial$  \\
    \verb+\star+     & $\star$  & \verb+\gg+     &  $\gg$         & 
    \verb+\emptyset+ & $\emptyset$  & \verb+\wedge+ &  $\wedge$     \\
    \verb+\setminus+ & \backslash & \verb+\sim+ &  $\sim$       & %setminus与unicode-math包冲突，会显示空白
    \verb+\forall+   & $\forall$  & \verb+\vee+   &  $\vee$         \\
    \verb+\oplus+    & $\oplus$  & \verb+\simeq+    &  $\simeq$   & 
    \verb+\infty+    & $\infty$  & \verb+\cup+    &  $\cup$         \\
    \verb+\ominus+   & $\ominus$  & \verb+\approx+   &  $\approx$ & 
    \verb+\exists+   & $\exists$  & \verb+\cap+   &  $\cap$   
  \end{tabular}
  \caption{常用数学符号}
  \label{tab:3.1}
\end{table}

\begin{ii}
我们盘点了latexsym和amssymb包中的近450个符号（参见附录C）%TODO
。目的不是介绍它们！表\ref{tab:3.1}是标准符号中的一部分，我们认为它们可能是最常用的那一批——除了完全偶然出现的$\aleph$\yz{
  aleph，希伯来文字母表的第一个字母。
}。也许这证明了作者的数学水平不太高。
\end{ii}

\subsubsection{省略号}

为了节省篇幅，数学式中经常使用省略号。省略号有三种，指令\verb|\dots|可以生成点“放置在”基线上的省略号：

\begin{codelist}[3.3]{
$C=\{\vec{c}_0,\vec{c}_1,\dots,
    \vec{c}_N\}$
为$N$个颜色的集合。
}\begin{verbatim}
$C=\{\vec{c}_0,\vec{c}_1,\dots,
    \vec{c}_N\}$
为$N$个颜色的集合。
\end{verbatim}
\end{codelist}

指令\verb|\cdots|生成的省略号圆点上下居中，就像等号一样：

\begin{codelist}[3.4]{
  $\vec{\mu}=\frac{1}{N}
(\vec{c}_0+\vec{c}_1+\cdots+\vec{c}_N)$
为$N$个颜色的平均值。
}\begin{verbatim}
$\vec{\mu}=\frac{1}{N}
(\vec{c}_0+\vec{c}_1+\cdots+\vec{c}_N)$
为$N$个颜色的平均值。
\end{verbatim}
\end{codelist}

最后，指令\verb|\vdots|和\verb|\ddots|主要在矩阵中使用（参见3.6节、例3.15）。这两个指令分别可以生成$\vdots$和$\ddots$这两种省略号。

\subsubsection{箭头}

用于生成箭头的指令可以使用以下简单的方法来记忆：

\begin{itemize}
  \item 所有指令均以\dm{arrow}结尾；
  \item 必须带有前缀\dm{left}或\dm{right}，表示方向；
  \item 可以带有前缀\dm{long}，表示加长；
  \item 指令的第一个字母可以改为大写，表示箭头使用双线；
  \item 可以连写\dm{left}和\dm{right}，表示双向箭头。
\end{itemize}

综上：

\begin{center}
  \begin{tabular}{lll|lll}
    \verb+\rightarrow+ & 表示  &$\rightarrow$ &
    \verb+\Longleftarrow+ & 表示 & $\Longleftarrow$ \\
    \verb+\Leftarrow+ & 表示 &$\Leftarrow$ &
    \verb+\Longleftrightarrow+ & 表示 &$\Longleftrightarrow$
  \end{tabular}
\end{center}

\subsubsection{希腊字母}

可以以一种极简单的方式使用希腊字母：打出它们的名字。也就是说，\verb|\alpha|表示$\alpha $，\verb|\pi|表示$\pi $。将指令的第一个字母改为大写，表示将对应希腊字母改为大写：\verb|\Gamma|表示$\Gamma $。注意，不是所有大写希腊字母都有对应的指令，如果要将$\alpha $改为大写，直接使用字母A即可（指令\verb|\Alpha|不存在）。

\subsubsection{实数集}

科技文档的作者常常会面临一个“至关重要”的问题：“我们应当如何打出代表实数集的字母`R'？”关于这个问题，这里分享几个观点。从历史上看，似乎最初的数学资料上将实数符号排版为加粗的形式（“令$x \in \mathbf{R}$”），老师们会使用粉笔反复在字母“R”上描几遍，来代表这个符号。这种比较烦琐的方法促成了我们“更熟悉”的写法：“令$x \in \mathbbm{R}$”。因此，出现了不同的流派：$\mathbf{R}$、ℝ，等等。如果你想自己选择，那么有如下包和指令供你选择：

\begin{itemize}
  \item \textsf{bbm}提供的指令\verb|\mathbbm{R}|可以生成$\mathbbm{R}$、指令\verb|\mathbbmss{R}|可以生成$\mathbbmss{R}$，等等；
  \item \textsf{bbold}提供的指令\verb|\mathbbm{R}|可以生成$\mathbbm{R}$；
  \item \textsf{amssymb}提供的指令\verb|\mathbb{R}|可以生成ℝ、指令\verb|\mathbf{R}|可以生成$\mathbf{R}$。
\end{itemize}

\section{函数}

\subsection{标准函数}

要生成经典的数学函数（如对数函数、三角函数等），需要使用\LaTeX 预装的函数来实现，这里是一个示例：

\begin{codelist}[3.5]{
$\sin^2x + \cos^2 x=1$
}\begin{verbatim}
$\sin^2x + \cos^2 x=1$
\end{verbatim}
\end{codelist}

如果不使用\LaTeX 函数：

\begin{codelist}[3.6]{
$sin^2x + cos^2x=1$
}\begin{verbatim}
$sin^2x + cos^2x=1$
\end{verbatim}
\end{codelist}

二者的区别在于，\LaTeX 会将字符串\dm{cos}视为一系列变量（因此生成意大利体），而将函数\verb|\cos|生成为罗马体的“cos”。另一个区别是对可能存在的下标的处理（参见以下\verb|\max|的示例）。以下函数都是\LaTeX 的标准数学函数。

\begin{itemize}
  \item 各种三角函数：\verb|\sin|、\verb|\cos|、\verb|\tan|。在前面加\dm{arc}，可以得到对应的反函数。在后面加\dm{h}，可以得到双曲三角函数。
  \item 自然对数和常用对数\yz{
    指以10为底的对数，标准的写法为$\lg$。本书以原书习惯为准，约定使用$\log$。
  }分别使用函数\verb|\ln|和\verb|\log|。
  \item 函数\verb|\sup|、\verb|\inf|、\verb|\max|、\verb|\min|、\verb|\arg|可以用于如下形式的数学式中：
  
  \begin{codelist}[3.7]{
    \begin{displaymath}
      T=\arg \max_{t<0} f(t)
    \end{displaymath}
  }\begin{verbatim}
\begin{displaymath}
  T=\arg \max_{t<0} f(t)
\end{displaymath}
  \end{verbatim}
  \end{codelist}
\end{itemize}

注意搭配\verb|\max|使用下标操作符\dm{\_}的结果。

\subsection{积分、求和和其他极限}

\LaTeX 使用一套简单的语法来生成\emph{积分}、\emph{求和}等内容，具体如下：

\begin{dmd}
\backslash \codereplace{操作}\verb|_{|\codereplace{下界}\verb|}^{|\codereplace{上界}\verb|}|
\end{dmd}

其中\codereplace{操作}可以是\dm{sum}、\dm{prod}、\dm{int}、\dm{lim}之一，\codereplace{上界}和\codereplace{下界}会排列在操作符号的周围。例如：

\begin{codelist}[3.8]{
  对此等比数列求和：
\begin{displaymath}
  \sum_{i=0}^{n}q^i=
  \frac{\quad 1-q^{n+1}}{1-q}
\end{displaymath}
}\begin{verbatim}
  对此等比数列求和：
\begin{displaymath}
  \sum_{i=0}^{n}q^i=
  \frac{1-q^{n+1}}{1-q}
\end{displaymath}
\end{verbatim}
\end{codelist}

类似地，使用指令\verb|\prod|可以生成求积符号$\prod$。
以下是使用积分的示例：

\begin{codelist}[3.9]{
对于$x>0$，定义自然对数如下：
\begin{displaymath}
  \ln(x)=\int_{1}^{x}\frac{1}{t}
  \,\mathrm{dt}
\end{displaymath}
}\begin{verbatim}
对于$x>0$，定义自然对数如下：
\begin{displaymath}
  \ln(x)=\int_{1}^{x}\frac{1}{t}
  \,\mathrm{dt}
\end{displaymath}
\end{verbatim}
\end{codelist}

指令\verb|\,|可以在“dt”前插入很小的空格（参见3.5.1小节）。你如果更喜欢\emph{线积分}，可以使用\verb|\oint|，这个指令可以生成符号$\oint$。好了，这里会给出一个关于极限的示例，相信你可以看懂：

\begin{codelist}[3.10]{
  $f(x)$在$x_0$处存在极限$\ell$：
\begin{displaymath}
  \lim_{x\rightarrow x_0}f(x)=\ell
\end{displaymath}
}\begin{verbatim}
$f(x)$在$x_0$处存在极限$\ell$：
\begin{displaymath}
  \lim_{x\rightarrow x_0}f(x)=\ell
\end{displaymath}
\end{verbatim}
\end{codelist}

希望你能注意到示例中漂亮的$\ell$。为了巩固一下关于两种数学模式的知识，这里给出相同的数学式，但它们这次会镶嵌在行文中：求和，$\sum_{i=0}^{n}q^i=\frac{1-q^{n+1}}{1-q}$；求积分，$\ln(x)=\int_{1}^{x}\frac{1}{t}\,\mathrm{dt}$；求极限，$\lim_{x\rightarrow x_0}f(x)=\ell$。

\section{重叠的符号}

\subsection{操作符\dm{not}}

操作符\verb|\not|可以生成特定关系的“否定”样式：

\begin{codelist}[3.11]{
  令实数$x \not\in I$……
}\begin{verbatim}
  令实数$x \not\in I$……
\end{verbatim}
\end{codelist}

\verb|\not|的输出结果就是在其下一个符号上加上一道“斜杠”。\textbf{注意}，这个操作符并不能总是呈现出完美的效果，例如\verb|$\not\longrightarrow$|会显示为$\not\longrightarrow$。但对于宽度合适的符号，它给出的结果还能令人满意。

\subsection{“变音符号”}

对于特殊的数学概念，经常需要\jz{
  实际上，一些名副其实的大数学家很喜欢这种符号上面的小帽子。一些人甚至还喜欢在上面叠两层、三层……
}在符号上加“变音”符号。以下是可用的符号示例：

\begin{center}
  \begin{tabular}{lc@{\quad}lc@{\quad}lc}
    \verb+\hat{x}+  &$\hat{x}$  & \verb+\check{x}+&$\check{x}$&
    \verb+\breve{x}+&$\breve{x}$\\
    \verb+\acute{x}+&$\acute{x}$& \verb+\grave{x}+&$\grave{x}$&
    \verb+\tilde{x}+&$\tilde{x}$\\ 
    \verb+\bar{x}+  &$\bar{x}$  & \verb+\dot{x}+&$\dot{x}$&
    \verb+\ddot{x}+ &$\ddot{x}$\\  
  \end{tabular}
\end{center}


\subsection{向量}

有两种\jz{
由埃迪·索德雷（Eddie Saudrais）开发的包\textsf{esvect}可以为向量生成更好看的箭头。
}方式可以得到向量：

\begin{itemize}
  \item 对于小些的符号，可以使用\verb|\vec|，因为这个指令是用于添加“变音”符号的。
  \item 对于其他情况，可以使用\verb|\overrightarrow|。
\end{itemize}

\begin{codelist}[3.12]{
设$\overrightarrow{A\!B}$在基底
$(\vec{\imath},\vec{\jmath})$
下定义。
}\begin{verbatim}
设$\overrightarrow{A\!B}$在基底
$(\vec{\imath},\vec{\jmath})$
下定义。
\end{verbatim}
\end{codelist}

注意，\verb|$\vec{A\!B}$|会显示为$\vec{A\!B}$（关于\verb|\!|的用途，参见3.5.1小节）。此外，指令\verb|\imath|和\verb|\jmath|分别可以生成不带点的字母i和j：$\imath$、$\jmath$。

\subsection{指令\dm{stackrel}}

指令\verb|\stackrel|可以将两个符号叠放在一起：

\begin{dmd}
\verb|\stackrel{|\codereplace{符号$_1$}\}\{\codereplace{符号$_2$}\}
\end{dmd}

\codereplace{符号$_1$}会置于\codereplace{符号$_2$}上方。例如：

\begin{dmd}
\verb|x\stackrel{f}{\longmapsto}y|
\end{dmd}

以上代码会生成$x\stackrel{f}{\longmapsto}y$。

\section{两个重要原则}

为了掌握\LaTeX 生成数学式的方法，需要知道以下两个原则。

\begin{description}
  \item[空格] \LaTeX 会忽略数学式中夹带的空格，因此\verb|$x+1$|和\verb|$x + 1$|生成的结果是相同的。\LaTeX 会在它认为最合适的地方添加空格。
  \item[文本] 任何的符号组都会被当作同一系列变量或函数对待，因此\verb|$x=t avec t>0$|\yz{
    此问题几乎只在西文排版中出现，因此保留原文。avec可理解为“且其中”。
  }会生成“$x=t avec t>0$”，而不是你所期待的“$x=t$ avec $t>0$”
  \jz{
    数学式中夹带文本的问题只会在使用\dm{displaymath}系列的环境时显现出来。毕竟，使用“\dm{\$x=t\$ avec \$t>0\$}”总是可以的！
  }。
\end{description}

在了解了两个原则后，来看看入门如何处理相关的问题。

\subsection{数学模式的空格}

首先需要知道，\LaTeX 选择添加空格的方式一般是正确的。然而，如果有一天你非要去\rlap{ㄨㄨㄨㄨ}吹毛求疵，表\ref{tab:3.2}可以帮助你在数学式中插入空格。在该表格中，我们在两个$\Box$符号之间夹入不同的空格指令，来展示它们的效果。

\begin{table}[ht]
  \begin{center}
    \begin{tabular}{|ll|ll|ll|ll|}
      \hline
      \verb+\!+ & $\Box\!\Box$ &
      \emph{无指令} & $\Box\Box$ &
      \verb+\,+ & $\Box\,\Box$ &
      \verb+\:+ & $\Box\:\Box$ \\
      \hline
      \verb+\;+ & $\Box\;\Box$ &
      \verb*+\ + & $\Box\ \Box$ &
      \verb|\quad| & $\Box\quad\Box$ &
      \verb|\qquad| & $\Box\qquad\Box$ \\
      \hline
    \end{tabular}
    \caption{数学模式中的空格}
    \label{tab:3.2}
  \end{center}
\end{table}

对于那些关注“毛”“疵”的人，要强调一下，本书在等比数列的示例（参见3.3.2小节）中偷偷了在分子上添加了一些空格，以让分式中的两个$q$稍微对齐。如果按照默认的生成方式，结果会是这样的：

\begin{displaymath}
  \sum_{i=0}^{n}q^i=
  \frac{1-q^{n+1}}{1-q}
\end{displaymath}

不知道这个关于$q$的故事是否为你带来了更敏锐的观察力。

\subsection{数学模式中的文本}

在数学式中插入文本，最简单的方法是将文本“装箱”，并适当地插入空格：

\begin{codelist}[3.13]{
设数列$(u_n),(v_n)$：
\begin{displaymath}
  u_n=\ln n\quad
  \mbox{且}\quad v_n=(1+\frac{1}{n})^n
  \label{ex-maths-suite}
\end{displaymath}
}\begin{verbatim}
设数列$(u_n),(v_n)$：
\begin{displaymath}
  u_n=\ln n\quad
  \mbox{且}\quad v_n=(1+\frac{1}{n})^n
  \label{ex-maths-suite}
\end{displaymath}
\end{verbatim}
\end{codelist}

你可以在4.4.1小节找到关于指令\verb|\mbox|的细节。如果你已经在考虑使用包\textsf{amsmath}，相比于使用\verb|\mbox|，也可以考虑使用指令\verb|\text|。

\section{阵列（array）：简单且高效}

阵列环境\dm{array}可以满足生成大多数数学式的需求。正如其名，它可以将对象排列成一行行、一列列的样子。实际上，它和环境\dm{tabular}对应。也正如\dm{tabular}一样，\dm{array}也不会换行。

